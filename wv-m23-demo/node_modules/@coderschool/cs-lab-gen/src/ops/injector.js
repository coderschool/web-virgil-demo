const EOL = require("os").EOL;
const EOLRegex = /\r?\n/;

const newline = (string) => {
  const newlines = string.match(/(?:\r?\n)/g) || [];

  if (newlines.length === 0) {
    return EOL;
  }

  const crlf = newlines.filter((newline) => newline === "\r\n").length;
  const lf = newlines.length - crlf;

  return crlf > lf ? "\r\n" : "\n";
};

const getPragmaticIndex = (pattern, lines, isBefore) => {
  const oneLineMatchIndex = lines.findIndex((l) => l.match(pattern));

  // joins the text and looks for line number,
  // we dont care about platform line-endings correctness other than joining/splitting
  // for all platforms
  if (oneLineMatchIndex < 0) {
    const fullText = lines.join("\n");
    const fullMatch = fullText.match(new RegExp(pattern, "m"));

    if (fullMatch && fullMatch.length) {
      if (isBefore) {
        const fullTextUntilMatchStart = fullText.substring(0, fullMatch.index);
        return fullTextUntilMatchStart.split(EOLRegex).length - 1;
      }
      const matchEndIndex = fullMatch.index + fullMatch.toString().length;
      const fullTextUntilMatchEnd = fullText.substring(0, matchEndIndex);
      return fullTextUntilMatchEnd.split(EOLRegex).length;
    }
  }

  return oneLineMatchIndex + (isBefore ? 0 : 1);
};
const locations = {
  at_line: (_) => _,
  prepend: (_) => 0,
  append: (_, lines) => lines.length - 1,
  before: (_, lines) => getPragmaticIndex(_, lines, true),
  after: (_, lines) => getPragmaticIndex(_, lines, false),
};
const indexByLocation = (attributes, lines) => {
  const pair = Object.entries(attributes).find(([k, _]) => locations[k]);
  if (pair) {
    const [k, v] = pair;
    return locations[k](v, lines);
  }
  return -1;
};
const injector = (action, content, logger) => {
  const {
    attributes: { skip_if, eof_last },
    attributes,
    body,
  } = action;
  // eslint-disable-next-line
  const shouldSkip = skip_if && !!content.match(skip_if);

  if (!shouldSkip) {
    //
    // we care about producing platform-correct line endings.
    // however the "correct" line endings should be detected from the actual
    // CONTENT given, and not the underlying operating system.
    // this is similar to how a text editor behaves.
    //
    const NL = newline(content);
    const lines = content.split(NL);

    if (!attributes.remove_lines) {
      // returns -1 (end) if no attrs
      const idx = indexByLocation(attributes, lines);

      // eslint-disable-next-line
      const trimEOF = idx >= 0 && eof_last === false && /\r?\n$/.test(body);
      // eslint-disable-next-line
      const insertEOF = idx >= 0 && eof_last === true && !/\r?\n$/.test(body);

      if (trimEOF) {
        lines.splice(idx, 0, body.replace(/\r?\n$/, ""));
      } else if (insertEOF) {
        lines.splice(idx, 0, `${body}${NL}`);
      } else if (idx >= 0) {
        lines.splice(idx, 0, body);
      }
    } else {
      const { from, at_line } = attributes.remove_lines;
      if (from !== undefined || at_line !== undefined) {
        const idx = from
          ? indexByLocation({ before: from }, lines)
          : indexByLocation({ at_line: at_line }, lines);
        if (idx >= 0) {
          if (attributes.remove_lines.to && attributes.remove_lines.to > 0) {
            lines.splice(idx, attributes.remove_lines.to);
          } else {
            logger.warn(`Remove Lines ignored - remove_lines.to is invalid, `);
          }
        } else {
          logger.warn(`Remove Lines ignored - start line not found, `);
        }
      } else {
        logger.warn(
          `Remove Lines: Invalid syntax: ${JSON.stringify(
            attributes.remove_lines,
            null,
            2
          )}`
        );
      }
    }

    return lines.join(NL);
  } else {
    return content;
  }
};

module.exports = injector;
